# 浏览器中的页面

## 页面性能分析：利用chrome做web性能分析

### Chrome 开发者工具

它一共包含了 10 个功能面板，包括了 Elements、Console、Sources、NetWork、Performance、Memory、Application、Security、Audits 和 Layers

### 网络面板

网络面板由控制器、过滤器、抓图信息、时间线、详细列表和西撒在信息概要这六个区域组成

<img src="./panel.png" width="70%">

时间线面板

<img src="./timing.png" width="70%">

queuing, 排队中， 浏览器发起请求不会立即执行，需要进入队列中

- 页面的资源有优先级, 核心文件高优先级, 图片等文件低优先级
- 每个域名只有 6 个 TCP 链接, 超出须进入队列
- 网络进程为数据分配磁盘空间, 新的 HTTP 请求也要进入队列

排队完成后, 要发起连接的状态, 但是在发起连接前因为其他的原因, 导致连接推迟, 反映在 stalled 中

initial connection/SSL 阶段, 和服务器建立连接阶段, 包括建立 TCP 的时间

request sent 阶段, 和服务器建立连接之后, 网络进程会准备请求数据, 并将其发送给网络, 速度非常快, 通常不到 1ms

waiting (TTFB), 数据发送出去了, 等待接收服务器第一个字节的数据, 时间越短, 说明服务器响应快

content downing, 从第一个字节到所有数据接收的时间

## DOM树：JavaScript是如何影响DOM树构建的

### 什么是 DOM

DOM 的三个作用:

1. DOM 是生成页面的基础数据结构
2. 从 js 角度, DOM 提供一套接口用来更改页面结构
3. DOM 也是一道安全防线, 不安全的内容在解析阶段就拒之门外

### DOM 树如何生成

网络进程加载多少数据, HTML 解析器便解析多少数据

字节流转换为 DOM 需要三个阶段

1. 通过分词器将字节流转换为 Token
2. 第二和第三阶段同步进行的, 将 Token 解析为 DOM 节点, 并将 DOM 节点添加到 DOM 树中

### javascript 如何影响 DOM 生成

在解析 HTML 文件的时候, 如果遇到 script 标签, HTML 解析器会暂停, js 引擎会介入, 脚本执行完成后继续 HTML 解析

在执行 js 代码之前, 需要下载脚本, 这会阻塞 DOM 的解析

如果 js 脚本中没有操作 DOM 的相关代码, 可以设置为异步加载, 使用 async 和 defer 来标记

```js
//加载完成, 立即执行
<script async type="text/javascript" src='foo.js'></script>
//加载完成, 在 DOMcontentLoaded 后执行
<script defer type="text/javascript" src='foo.js'></script>
```

JavaScript 引擎在解析 JavaScript 之前，是不知道 JavaScript 是否操纵了 CSSOM 的，所以渲染引擎在遇到 JavaScript 脚本时，不管该脚本是否操纵了 CSSOM，都会执行 CSS 文件下载，解析操作，再执行 JavaScript 脚本。

## 渲染流水线：CSS如何影响首次加载时的白屏时间

渲染流水线示意图

<img src="./pipeline.png" width="70%">

### CSSOM

CSSOM 的作用

1. 提供给 js 操作样式表的能力
2. 为布局树的合成提供基础的样式信息

布局树的结构基本上就是复制 DOM 树的结构，不同之处在于 DOM 树中那些不需要显示的元素会被过滤掉

复制好基本的布局树结构之后，渲染引擎会为对应的 DOM 元素选择对应的样式信息，这个过程就是样式计算。样式计算完成之后，渲染引擎还需要计算布局树中每个元素对应的几何位置，这个过程就是计算布局

有外部引用的 CSS js 的渲染流水线

<img src="./pipeline2.png" width="70%">

## 分层和合成机制：为什么 CSS 动画比 JavaScript 高效？

### 浏览器是怎么显示图像的

显示器有固定的刷新频率, 更新的图片来自显卡中的**前缓冲区**的地方

显卡合成新的图像, 将图像保存在**后缓冲区**中, 然后系统将前缓冲区和后缓冲区互换

### 帧和帧率

大多数显示器的更新频率是 60hz, 所以在动画流畅的情况下, 渲染引擎需要每秒更新 60 张图片到显卡的后缓冲区

### 如何生成一帧图像

生成帧的方式有重排、重绘和合成三种方式

渲染路径越长, 生成图像花费的时间就越多

chrome 的合成技术, 可以用三个词概括: 分层、分块和合成

在 Chrome 的渲染流水线中, 分层体现在生成布局树之后, 渲染引擎会将布局树转换为层树(Layer Tree), 层树是渲染流水线后续流程的基础结构

层树中的每个节点都对应一个图层,

绘制阶段并不是真正地绘出图片, 而是将绘制指令组合成一个列表, 列如 `Paint BackGroundColor: Black; Paint Circle`

有了绘制列表之后, 就进入光栅化阶段, 光栅化就是按照绘制指令生成图片, 渲染进程有了这些图片, 会将这些图片合成为一张图片, 发送给后缓冲区

> 合成操作是在合成进程中的, 也就意味着在执行合成进程的时候是不会影响到主进程的, 也就是主进程卡住了, 但是 CSS 动画依然能够执行的原因

### 分块

合成线程会将图层分成大小固定的图块, 优先绘制靠近视口的图块,

首次合成图块的时候使用一个低分辨率的图块

### 利用分成技术优化代码

可以使用 will-change 使合成线程参与渲染

```css
.box{
    will-change: transform, opacity;
}
```

这段代码就是提前告诉渲染引擎 box 元素将要做几何变换和透明度变换操作，这时候渲染引擎会将该元素单独实现一层，等这些变换发生时，渲染引擎会通过合成线程直接去处理变换，这些变换并没有涉及到主线程，这样就大大提升了渲染的效率

## 页面性能：如何系统地优化页面？

页面分为三个阶段:

1. 加载阶段, 从发出请求到渲染出完整页面的阶段
2. 交互阶段, 页面加载完成到用户交互的整合过程
3. 关闭阶段, 用户发出关闭指令后页面所作的一些清理操作

### 加载阶段

阻塞页面首次加载的资源称为**关键资源**

三个影响首次渲染的核心因素:

1. 关键资源个数
2. 关键资源大小
3. 关键资源需要多个 RTT(round trip time) 

> 优化的总原则:减少关键资源个数、减少关键资源大小、降低关键资源 RTT

### 交互阶段

交互阶段的优化, 是指渲染进程的渲染速度. 帧的渲染速度决定了交互的流畅度

交互阶段通常是由 js 触发交互动画

<img src="./render.png" width="70%">

大部分情况, 生成新的帧是由 js 通过修改 DOM 或者 CSSOM 来触发的, 另外的一部分帧是由 CSS 触发的

> 在计算样式阶段发现有布局信息的修改, 会触发**重排**操作, 然后会触发渲染流水线的一系列操作, 代价比较大

重排和重绘额区别: 重绘不一定重排(比如改变颜色), 重排一定导致重绘(改变网页位置)

1. 重排: 渲染树的一部分节点更新, 浏览器会使受到影响的部分失效, 重新构造渲染树
2. 重绘: 元素的属性改变, 浏览器会根据元素的新属性重新绘制

### 减少 js 脚本执行时间

js 函数的依次执行时间过长, 会严重影响主线程执行其他的渲染任务的时间

策略:
1. 将执行的函数分解为多个任务, 每次的执行时间不要过久
2. 采用 web worker, web worker 相当于主线程之外的另外的线程, 但是 web worker 中没有 DOM CSSOM 环境, 可以把与 DOM 无关的任务放到 web worker 中执行

### 避免强制同步布局

js 中操作 DOM 元素, 如果在 js 中执行布局相关操作, 会强制在 js 任务中进行重新布局, 延长 js 执行时间

### 避免布局抖动

不要在一次 js 执行过程中, 多次强制布局和抖动操作, 会严重影响当前函数的执行效率

### 合理使用 CSS 合成动画

合成动画直接在合成线程上执行, 不会受到主线程的情况影响, 能让 CSS 处理动画, 尽量交给 CSS 处理

> 动画元素执行动画操作, 最好将其标记为 will-change, 告知渲染引擎需要将该元素单独生成一个图层

### 避免频繁的垃圾回收

在函数中频繁创建临时对象, 垃圾回收机制会频繁的执行垃圾回收策略, 会占用主线程, 影响到其他任务的执行, 会产生掉帧

> 尽可能优化存储节后, 尽可能避免小颗粒对象的产生


