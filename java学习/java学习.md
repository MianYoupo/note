# java学习

java 中的作用域是在 public class 中的。

作用域就是大括号

变量的分类

 * 局部变量

   在方法体当中生命的变量叫做局部变量

* 成员变量

  在方法体外【类体之内】声明的变量叫成员变量

数据类型

​	java中的数据类型有两种

  * 基本数据类型

    * 整数型

      byte, short, int, long

    * 浮点型

      float, double

    * 布尔型

      boolean

    * 字符型

      char

  * 引用数据类型

    * 字符串

字符编码

八种基本数据类型的默认值都是0或者0的变形。

单引号内部是字符

双引号内部是字符串

jdk中自带的 native2ascii 可以将中文字符转换为 unicode 字符

\u 代表后面的字符是 unicode 编码

java 在为变量赋值的时候，将数字首先作为 int 进行处理，然后在赋值给对应的变量。如果数值超过四个字节，就会出现数据溢出的错误。

```java
long z = 2147483648  //会报错
long z = 2147483648L //不会报错，这里将数字先作为 long 处理
```

小容量可以向大容量自动进行转换。

大容量转换为小容量，需要强制转换。强制转换数字类型的话，就是用截断的方法。

```java
int y = (int)x	//进行强制类型转换。
```



整型如果大小没有超过一字节，可以直接赋值给 byte 类型。不会存在强制转换。

```java
byte b = 127  //没有报错
```

补码：

正整数的补码与原码相同，负整数的补码为符号位不变，其余位取反然后加一。

java提供了高精度的数据类型，是引用数据类型。

java为浮点类型赋值的时候，会将浮点数当作 double 类型处理。如果赋值给 float 类型变量的话，必须要进行强制转换。

```java
float f = (float)5.1	//强制类型转换
float f = 5.1f //没有前置类型转换，直接将5.1当作 float 类型处理
```

**编译器在编译的时候不会运行，只会检查语法。**

拓展运算符不改变变量的数据类型，如下

```java
byte z = 10
z += 10 //这个不会触发语法错误，但是 z = z + 10,会触发语法错误，可见两者不是完全相同
```

三元运算符不是一个语句，是一个运算符。

三元运算符也要注意表达式的类型问题

```java
char a = sex ? 'man' : "woman"  // 这个会出现类型错误，因为 a 可能为 char 或者 string
```

switch 语句中条件部分，可以接受 int 和 string 类型，如果不是，首先进行类型转换（小转大）。

java 方法初步

方法定义在类体中，在一个类中可以定义多个方法，方法编写的位置可以随意。

方法体当中不能再定义方法。**这个特别**

```
1.方法怎么定义，语法结构
	[修饰符列表] 返回值类型 方法名（形式参数列表）{
		方法体
	}
2.对以上的解释：
	2.1关于修饰符列表
		* 可选项，不是必须的
		* 方法的修饰符列表中有 static 关键字的，是用如下的调用的方法
			-类名.方法名（实际参数列表）
	2.2返回值类型
		* 返回值是一个具体存在的数据，此处需要制定返回的类型
		* 返回的类型是 java 中的任意类型
		* 如果不返回数据，是用 void 关键字。
```

java 内存图

1. 方法只定义，不调用。JVM不会给该方法分配**运行所属**的内存空间。
2. 在 JVM 内存划分
   * 方法区内存
   * 堆内存
   * 栈内存

方法的重载机制 overload

​	功能相同的方法，根据传入参数的类型不同而有不同的返回值。这种情况下可以使用相同的方法名，但是 JVM 会根据传入的数据类型调用不同的方法。这种叫做方法的重载。

```java
public class OverloadTest {
	public static void main(String[] args) {
		System.out.println(sum(1,2));
    System.out.println(sum(1.0,2.0));
    System.out.println(sum(1L,2L))
  }
  public static int sum(int a, int b) {
    return a + b;
  }
  public static long sum(long a, long b) {
  	return a + b;
  }
  public static double sum(double a, double b) {
  	return a + b;
  }
}
```

方法重载的参数列表遵从以下规则：

​	数量不同

​	顺序不同

​	类型不同

```java
//以下均构成方法重载
public static void m1(){}
public static void m1(int a){}

public static void m2(int a,double b){}
public static void m2(double a,int b){}

public static void m3(int x){}
public static void m3(double x){}
```

面向对象 java 核心机制

面向对象的三大特征

	* 封装
	* 继承
	* 多态

面向对象的分析 OOA

面向对象的设计 OOD

面向对象的编程 OOP

类体 = 属性 + 方法

变量定义在类体当中，方法体之外，这种变量成为成员变量。

变量不能直接通过**类**访问的变量，这种变量成为实例变量。

new 运算符在堆内存中开辟的内存空间称为对象

自定义的类可以作为数据类型

JVM 内存

	* stack
	* heap
	* 方法区内存

java 封装性

```
setter and getter 方法没有 static 关键字
有 static 关键字修饰的方法的调用： 类名.方法名(实参)
没有 static 滚剪子修饰的方法怎么调用： 引用.方法名(实参)
```

构造方法

```
构造方法语法结构
	[修饰符列表] 构造方法名 (形式赞数列表) {
		构造方法体
	}
	
普通方法语法结构
	[修饰符列表] 返回值类型 方法名 (形式参数列表) {
		方法体
	}

对于构造方法来说，构造方法的方法名必须和类名保持一致。并且返回值类型不需要指定。如果指定返回值，构造方法就变化为普通方法。

构造方法有返回值，返回值类型就是构造的类。
类中没有构造方法的时候，java 会自动给类创建一个缺省构造器，缺省构造器没有参数。
当类显示的将构造方法定义出来了，Java 不再提供缺省构造器。但是可以自定义一个无参数构造方法。
构造方法也是可以重载的。

```



this 关键字

java 中 this 指向自身。

在 static 的方法中，不能够直接访问实例变量和实例方法。实例变量和实例方法都需要对象的存在。而 static 的方法当中是没有 this 的，也就是对象不存在。

this 可以在构造方法中，通过当前的构造方法调用其他的构造方法。

```
这个方法只能出现在首行，用来调用其他的构造方法
this(xxx)
```



静态代码块

​	可以用来记录日志，当类加载的时候，立即执行静态代码块中的任务。

```
语法格式：
	static {
		Java 语句；
	}
静态代码块在类加载时执行，并且只执行一次。
静态代码块在一个类中可以编写多个，按照顺序执行
```

静态代码块是 Java 为程序员准备的一个特殊的时刻，这个特殊的时刻被称为类加载时刻。若希望在此刻执行一段程序，就把方法写在静态代码块中。



实例代码块（了解，使用非常少）

```
实例代码块可以编写多个，遵循自上而下的顺序依次执行
实例代码块在构造方法执行之前执行，
实例代码块在构造方法执行前执行，实例代码块依次执行，构造方法执行一次。
实例代码块是 java 语言为程序员准备一个特殊的时机，对象初始化时机。
```



静态方法

```
方法描述的动作，当所有的对象执行这个动作的时候，最终产生影响是一样的，那这个动作已经不再属于某一个对象动作了，可以将这个动作提升为类级别的动作。
```



类总结

```
class 类 {
	静态代码块
	实例代码块
	
	静态变量
	实例变量
	
	构造方法
	
	静态方法
	实例方法
}
```



静态方法中无法直接访问**实例变量**和**实例方法**

大多数方法都定义为实例方法，一般一个动作在发生的时候，都需要对象的参与。但是有例外，对于**工具类**中的方法都是静态方法，因为工具类就是方便编程，为了方法的调用，自然不需要 new 对象。



关于 Java 语言中的继承

```
1.继承是面向对象的三大特征，分别是：封装、继承、堕胎
2.继承的基本作用：代码复用。继承最重要的作用是：有了继承后才有了方法的覆盖和多态机制。
3.继承语法格式：
	[修饰列表] class 类名 extends 父类名 {
		类体 = 属性 + 方法
	}
4.Java 语言当中的继承只支持单继承，一个类不能同时继承很多类，只能继承一个类。
5.关于继承中的一些属于：
	B类继承A类，其中：
	A类称为：父类、基类、超类、superclass
	B类称为：子类、派生类、subclass
6.继承哪些数据：
	私有的数据不支持继承
	构造方法不支持继承
	其他数据可以继承
7.Java语言只支持单继承，但是一个类也可以间接继承其他类。
8.Java 语言中假设一个类没有显示的继承任何类，该类默认继承 Javase 中的 java.lang.Object类

```



方法的覆盖

```
1.方法覆盖又叫方法重写，override/overwrite
2.什么时候使用方法覆盖？
	父类中的方法已经无法满足当前子类的业务
	子类有必要将父类中继承过来的方法进行重新编写
3.方法覆盖的触发条件
	在满足继承关系的父类和子类中
	返回值类型相同，方法名相同，参数列表相同
	访问权限只能更高 public>protected>default>private
	抛出的异常只能更少
4.建议方法覆盖的时候要复制
5.注意：
	私有方法不能继承，所以不能覆盖
	构造方法不能继承，所以不能覆盖
	静态方法不存在覆盖。
	覆盖只针对方法，不针对属性
```



多态

```
多态中涉及到的几个概念：
	向上转型 upcasting
		子类型--->父类型
		又被称为：自动类型转换
	向下转型 downcasting
		父类型--->子类型
		又被称为：强制类型转换。[需要加强制类型转换符]
	注意：
  	无论是向上转型还是向下转型，两种类型之间必须要有继承关系，没有继承关系，程序是无法编译通过的。
```

向上转型

```
1.Java 程序分为编译阶段和运行阶段
2.编译无法通过，程序就无法执行。
3.编译阶段编译器检查 a2 这个引用的数据类型为 animal，由于 animal.class 字节码当中有 move()方法，所以编译通过。这个过程称为静态绑定
4.在程序运行阶段，JVM堆内存当中真实创建的对象是 Cat 对象，那么程序运行的时候调用的是 Cat 对象中的 move 方法，而不是编译阶段参考的 animal 对象。此时发生了程序的动态绑定，运行阶段绑定。
5.无论 Cat 类有没有定义 move 方法，运行阶段调用的一定是 Cat 类
6.父类型引用指向子类型对象这种机制导致程序存在编译阶段绑定和运行阶段绑定，这种机制称为一种多态语法机制。
```

向下转型

```
向下转型也需要两种类型之间必须有继承关系，不然编译报错

当调用的方法是子类型中特有的，在父类型当中不存在，必须进行向下转型。

向下转型的程序编译虽然通过了，但是会在运行阶段出现异常， java.lang.ClassCastException 类型转换异常。也就是说向下转型存在隐患。
```

instanceof 运算符

```
语法格式：
	引用 instanceof 数据类型
运算符返回类型是布尔类型
```



final 关键字

```
1.final 是一个关键字，表示最终的、不可变的
2.final 修饰的类无法被继承
3.final 修饰的方法无法被覆盖
4.final 修饰的变量一旦赋值之后，不可重新赋值
5.final 修饰的实例变量，不能重新赋值。
6.final 修饰的引用，不能被其他对象覆盖。并且也不会被垃圾回收机制回收。
```

所有的程序都尽量链接源码，养成看源码的习惯。

final 修饰的引用，是可以改变引用的对象中的值的。



常量的语法格式

```
public static final 类型 常量名 = 值
```



Java 语言中的包机制

```
1.Java 中引入 package 这种语法机制是为了方便管理程序。
	不同功能的类被分门别类放到不同的软件包当中，查找比较方便。
2.定义 package
	在 Java 源程序的第一行上编写 package 语句
	package 只能编写一个语句
	语法结构：
		package 包名
3.包名的规范
	公司域名倒序 + 项目名 + 模块名 + 功能名
4.包名要求全部小写，包名也是标识符，必须遵守标识符命名规范
5.一个包将来对应的是一个目录
6.使用了 package 机制之后，类名不再是文件名，而是 包名.类名
```

在同一个目录下，使用类名是可以省略包名的。

lang 包下的 class 不需要导入。

lang: language 语言包，是 Java 语言的核心类，不需要手动引入。



访问控制权限和修饰符

```
1.访问控制权限修饰符来控制元素的访问范围
2.访问控制权限修饰符包括
	public	表示公开的，在任何位置都可以访问
  protected	同包，子类
  default	同包
  private	表示私有的，只能在本类中访问
3.访问控制权限修饰符可以修饰类、变量、方法
4.当某个数据只希望子类使用，使用 protected 进行修饰
```



抽象类和接口

```
抽象类：
1.类和类的共同特征，将共同特征提取出来，就是抽象类。抽象类无法实例化
2.抽象类属于引用数据类型。
3.抽象类的语法
	[修饰符列表] abstract class 类名 {
		类体
	}
4.抽象类无法实例化，无法创建对象，所以抽象类是用来被继承的
5. abstract 和 final 不能同时出现。
6.抽象类的子类可以是抽象类，也可以是非抽象类
7.抽象类无法实例化，但是有构造方法，这个构造方法是供子类使用的。
8.抽象方法表示没有实现的方法，没有方法体的方法
	public abstract void doSome();
	抽象方法特点：
		没有方法体，以分号结尾。
		修饰符列表中有 abstract 关键字。
9.抽象类中不一定有抽象方法。抽象方法必须在抽象类中
```

一个非抽象的类继承抽象类，必须将抽象类的抽象方法覆盖。否则，编译出错。



接口

```
1.接口也是一种引用数据类型
2.接口是完全抽象的。（抽象类是半抽象），接口是特殊的抽象类。
3.接口的定义
	[修饰符列表] interface 接口名 {}
4.接口支持多继承，一个接口可以继承多个接口。
	interface A extends C,B{}
5.接口中只包含两部分内容，一部分是：常量。一部分是：抽象方法。没有其他内容
```

