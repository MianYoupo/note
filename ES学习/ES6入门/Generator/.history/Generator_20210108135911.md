# Generator 函数语法

## 简介

### 基本概念

Generator 函数是一个状态机, 封装了多个内部状态

执行 Generator 函数会返回一个遍历器

Generator 函数的两个特征:
1. function 关键字与函数名之间有一个星号
2. 函数体内部使用 yield 表达式

### yield 表达式

Generator 函数可以不用 yield 表达式, 成为一个单纯的暂缓执行函数

```js
function* f(){
  console.log('called');
}

var generator = f()

setTimeout(() => {
  generator.next()
}, 2000);
```

> yield 表达式只能用在 Geneator 函数内, 用在普通函数内会报错

yield 表达式如果在另外的表达式中, 必须放在圆括号内

```js
function* demo(){
  console.log('called');
  console.log('hello\n' + (yield 456));
  console.log('hello\n' + (yield 123));
}

var generator = demo()
console.log(generator.next());
console.log(generator.next());
console.log(generator.next());
```

yield 表达式用作函数参数或放在赋值表达式的右边, 可以不加括号

```js
function* demo() {
  foo(yield 'a', yield 'b')
  let input = yield
}
```

### 与 Iterator 接口的关系

Generator 函数就是遍历器生成函数, 可以把 Generator 赋值给对象的 Symbol.iterator 属性, 从而使对象有 Iterator 接口

```js
var myIterator = {}

myIterator[Symbol.iterator] = function* () {
  yield 1;
  yield 2;
  yield 3;
}

console.log([...myIterator]);
```

> Generator 函数执行后, 返回遍历器对象, 遍历器对象也有 Symbol.iterator 属性, 执行后返回的遍历器O对象**就是自己**

```js
function* gen(){

}

var g = gen()

console.log(g[Symbol.iterator]() === g);
```

## next 方法的参数

yield 表达式总是返回 underfined. next 方法可以带一个参数, 该参数皆被当做上一个 yield 表达式的返回值

```js
function* f(){
  for(var i = 0;true;i++){
    var reset = yield i;
    if(reset) { i = -1}
  }
}

var generator = f()
console.log(generator.next());
console.log(generator.next());
console.log(generator.next(true));
```

> 通过 next 方法的参数, 可以在 Generator 函数运行的不同阶段, 从外部像内部注入不同的值, 调整函数行为

如果想要在第一次调用 next 方法时, 能够输入值, 可以在 Generator 函数外面再包一层函数, 并且调用一次 Generator 状态

## 作为对象属性的 Generator 函数

```js
//以下两种写法是等价的
let obj = {
  * myGeneratorMethod(){}
}

let obj = {
  myGeneratorMethod: function* (){}
}
```

## Generator 函数的 this

Generator 函数返回一个遍历器, 这个遍历器是 Generator 函数的实例, 继承 Generator 函数的 prototype 对象上的方法

```js
function* g() {}

g.prototype.hello = function() {
  return 'hi'
}

let obj = g()

console.log(obj instanceof g)
console.log(obj.hello());
```

不能够把 Generator 函数当作普通的构造函数, 使用 new 关键字会报错

